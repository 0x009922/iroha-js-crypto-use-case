import {
  VersionedTransaction,
  Transaction,
  VecSignatureOfTransactionPayload,
  Signature,
  PublicKey,
} from "@iroha2/data-model";
import { crypto } from "@iroha2/crypto-target-node";
import { bytesToHex as numBytesToHex } from "hada";

// Bytes utilities

function bytesToHex(bytes: Uint8Array): string {
  return numBytesToHex([...bytes]);
}

const HEX_1 = `0114616c69636528776f6e6465726c616e640028000d0905243132372e302e302e3130636f6e747269627574696f6e030000090d0803243132372e302e302e3130636f6e747269627574696f6e14616c69636528776f6e6465726c616e640d040869640d03243132372e302e302e31090d0803243132372e302e302e3130636f6e747269627574696f6e14616c69636528776f6e6465726c616e640d040866740d0003000000090d0803243132372e302e302e3130636f6e747269627574696f6e14616c69636528776f6e6465726c616e640d040c6f72670d03085553090d0803243132372e302e302e3130636f6e747269627574696f6e14616c69636528776f6e6465726c616e640d040c6473740d03085a41090d0803243132372e302e302e3130636f6e747269627574696f6e14616c69636528776f6e6465726c616e640d040c7374730d0000000000090d0803243132372e302e302e3130636f6e747269627574696f6e14616c69636528776f6e6465726c616e640d040865640d0085ce3801090d0803243132372e302e302e3130636f6e747269627574696f6e14616c69636528776f6e6465726c616e640d040874730d0334313635353636383831393632350b0d0e8063616e5f7365745f6b65795f76616c75655f696e5f757365725f617373657473042061737365745f69640803243132372e302e302e3130636f6e747269627574696f6e14616c69636528776f6e6465726c616e640d08010c626f621461646d696e000d0907786f757464617465645f636f6e747269627574696f6e3132372e302e302e310004090d0803243132372e302e302e3130636f6e747269627574696f6e14616c69636528776f6e6465726c616e640d04546f757464617465645f636f6e747269627574696f6e0d020101010000000c626f621461646d696e02015880af62000000000000000000000f478d7d81010000005c26050000000001768e34870000`;
const buff = Uint8Array.from(Buffer.from(HEX_1, "hex"));
const { payload } = VersionedTransaction.fromBuffer(buff).as("V1");

const HEX_2 = `0114616c69636528776f6e6465726c616e640028000d0905243132372e302e302e3130636f6e747269627574696f6e030000090d0803243132372e302e302e3130636f6e747269627574696f6e14616c69636528776f6e6465726c616e640d040869640d03243132372e302e302e31090d0803243132372e302e302e3130636f6e747269627574696f6e14616c69636528776f6e6465726c616e640d040866740d0003000000090d0803243132372e302e302e3130636f6e747269627574696f6e14616c69636528776f6e6465726c616e640d040c6f72670d03085553090d0803243132372e302e302e3130636f6e747269627574696f6e14616c69636528776f6e6465726c616e640d040c6473740d03085a41090d0803243132372e302e302e3130636f6e747269627574696f6e14616c69636528776f6e6465726c616e640d040c7374730d0000000000090d0803243132372e302e302e3130636f6e747269627574696f6e14616c69636528776f6e6465726c616e640d040865640d0085ce3801090d0803243132372e302e302e3130636f6e747269627574696f6e14616c69636528776f6e6465726c616e640d040874730d0334313635353732373738353833360b0d0e8063616e5f7365745f6b65795f76616c75655f696e5f757365725f617373657473042061737365745f69640803243132372e302e302e3130636f6e747269627574696f6e14616c69636528776f6e6465726c616e640d08010c626f621461646d696e000d0907786f757464617465645f636f6e747269627574696f6e3132372e302e302e310004090d0803243132372e302e302e3130636f6e747269627574696f6e14616c69636528776f6e6465726c616e640d04546f757464617465645f636f6e747269627574696f6e0d020101010000000c626f621461646d696e0201ae66b062000000000000000000006c07118181010000005c26050000000001bb2889be00041c6564323535313980777d0d6bd65e37c70870c3bfd92a593adb75845ef9163223552cae521f97d98901013109beedd596d75943ab63f0feaba986d059cbf38542f63af0f6719b002032688bcd3158d9237a0375b748bd357bd6b1467f690ffec3ee670e5de5c7e43b8703`;
const buff2 = Uint8Array.from(Buffer.from(HEX_2, "hex"));

import { inspect } from "util";

const tx = VersionedTransaction.fromBuffer(buff2).as("V1");

console.log(
  bytesToHex(tx.signatures[0].public_key.payload)

  // inspect(
  //   VersionedTransaction.fromBuffer(buff2).as("V1"),
  //   false,
  //   Infinity,
  //   false
  // )
);

// console.log(`payload %o`, payload);

// const payloadBytes = responseBytes;
// const payloadHash = crypto.createHash(payloadBytes);
// const signature = crypto.createSignature(keyPair, payloadHash.bytes());
// const signatureBytes = signature.signatureBytes();

// let result;
// {
//   const publicKey = keyPair.publicKey();
//   const newSignedTransaction = Transaction({
//     payload,
//     signatures: VecSignatureOfTransactionPayload([
//       Signature({
//         public_key: PublicKey({
//           digest_function: publicKey.digestFunction(),
//           payload: publicKey.payload(),
//         }),
//         payload: signatureBytes,
//       }),
//     ]),
//   });
//   const encoded = VersionedTransaction.toBuffer(
//     VersionedTransaction("V1", newSignedTransaction)
//   );
//   result = toHexString(encoded);
// }
